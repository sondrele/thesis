% !TEX root = ../main.tex

\frontchapter{Abstract}
\label{chap:abstract}

Embedded computer systems are an invisible, ever-growing, part of our lives.
Through market trends, like the \glsdesc{iot}, these computers are brought to new domains.
These constrained systems sets different requirements to the tools used to develop software, compared to the conventional systems found in mobile, desktop, and server computers.

In recent decades, the number of programming languages has flourished on conventional computer systems.
The traditional categorization of \emph{high-level langauges} have shifted from static and hardware platform-agnostic languages like C, to the dynamic and highly managed languages like JavaScript.
The safety mechanisms provided by these new high-level langauges comes at a cost of the low-level control found in the now called \emph{low-level languages}.

Rust is an emerging programming language which has a new take on this trade-off between control and safety.
This language takes a static approach for guaranteeing the safety, which a high-level language needs to ensure with dynamic checking.

In this thesis, we present our experiments and evaluations of bringing Rust to an embedded computer system.
We describe the design and implementation of our \emhp{bare-metal} platform called {\rg}, which encompasses libraries for controlling the hardware device.
On this platform, we developed and evaluated several programs and abstract libraries.

To support our platform, we have developed and presented an extension to the Rust standard package manager, which facilitates building Rust applications for non-standard targets.
The extension was ultimately contributed back to the package manager project.

We have evaluated the platform based on performance, energy consumption, and code size.
These results where compared to the existing C platform for the target chip, the ARM Cortex-M3 based EFM32GG called Giant Gecko.
Our evaluation shows that Rust performs equally well when regarding performance and energy consumption.
However, we find that the code size can increase substantially, especially when building the applications in debugging mode.
