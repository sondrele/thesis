% !TEX root = ../main.tex

\chapter{Abstract}
\label{chap:abstract}

Embedded computer systems are an invisible, ever-growing part of our lives.
Through market trends, like the \glsdesc{iot}, these computers are brought to new domains.
These constrained systems set different requirements to the tools used to develop software, compared to the conventional systems found in mobile, desktop, and server computers.

In recent decades, the number of programming languages have flourished on conventional computer systems.
The traditional categorization of \emph{high-level languages} have shifted from static and hardware platform-agnostic languages like C, to the dynamic and highly managed languages like JavaScript.
The safety mechanisms provided by these new high-level languages come at a cost of the low-level control found in \emph{low-level languages}.

Rust is an emerging programming language that has a new take on this trade-off between control and safety.
This language takes a static approach for guaranteeing the safety, which a high-level language needs to ensure with dynamic checking.

In this thesis, we present our experiments and evaluate the result of bringing Rust to an embedded computer system.
We describe the design and implementation of our \emph{bare-metal} platform called {\rg}, which encompasses libraries for controlling the hardware device.
On this platform, we developed and evaluated several programs and abstract libraries.

To support our platform, we have developed and presented an extension to the Rust standard package manager, which facilitates building Rust applications for non-standard targets.
The extension was ultimately contributed back to the package manager project.

We have evaluated the platform based on performance, energy consumption, and code size.
These results were compared to the existing C platform for the target chip, the ARM Cortex-M3 based EFM32GG called Giant Gecko.
Our evaluation shows that Rust performs equally well when considering performance and energy consumption.
However, we find that the code size can increase substantially, especially when building the applications in debugging mode.
