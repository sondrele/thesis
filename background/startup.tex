\subsection{Startup}
\todo{Might be more implementation than background?}

The \textbf{main} function is usually considered the starting point of a program.
This is sometimes true from the point of view of the programmer, but as we will see in this section usually it is not.
This section looks at what happens before the program reaches the main function.

\subsubsection{Prelude}

Before we look at the start of execution, lets look at the process between compilation and execution.
The linker outputs a file in the \textbf{elf} file format.
This file is loaded into the microcontrollers ROM Flash memory.
Then the reset signal is sent to the CPU to start execution.

\paragraph{Executable and Linkable File Format}
%\todo{Reference: http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044e/IHI0044E\_aaelf.pdf}
\textbf{elf} is a file format for storing code and data for a program.
This file format can be loaded onto a microcontroller and executed.
For our purposes, this format defines three interesting sections, namely \textbf{.text}, \textbf{.data} and \textbf{.bss}.
Figure \ref{fig:elf} describes the contents of the these sections an \textbf{elf} file.

\begin{figure}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    EFL Header & Header describing size of sections \\
    \hline
    \textbf{.bss} & Logical section for zero-initialized data \\
    \hline
    \textbf{.text} & Read-only section for code and constants \\
    \hline
    \textbf{.data} & Section containing values for non-zero initialized data \\
    \hline
  \end{tabular}
  \caption{Sections of elf file format}
  \label{fig:elf}
\end{figure}

The \textbf{.text} section contains the program code and any read-only data defined in the code.
Strings are also stored in the \textbf{.text} section.
The \textbf{.data} section contains the values for non-zero initialized data.
The \textbf{.bss} section is a logical section so it is not really stored in the file.
The header specfies the size of the section which describes the size of the zero-initialized data in the program.

\subsubsection{Before main}

Before the \textbf{main} function executes, all static data must be initialized.
The data is divided into two categories; zero and non-zero initialized.
The non-zero initialized data are contained either in the \textbf{.text} (read-only-data) or \textbf{.data} sections of the \textbf{elf} binary.
On the chip the \textbf{.data} section resides in flash memory, and must be copied into RAM.
The \textbf{.text} section contains the instructions and read-only data, this data does not need to be copied as it is read directly from flash at runtime.
All zero initialized data are represented by the \textbf{.bss} section in the \textbf{elf} binary.

Copying the \textbf{.data} section into RAM is handled by the \textbf{ResetHandler} function in Figure \ref{fig:reset-handler}
The function is the real entry point of the program and is executed when the CPU receives the reset signal.

\begin{figure}[H]
\begin{verbatim}
// Variables set in linker script
extern etext;      // address of .data segment in FLASH
extern data_start; // start of .data segement in RAM
extern data_end;   // end of .data segment in RAM

void ResetHandler() {
  for (i=0; i<data_end - data_start; i++){
    RAM[data_start + i] = FLASH[etext+i];
  }
  _start();
}
\end{verbatim}
\caption{ResetHandler}
\label{fig:reset-handler}
\end{figure}

When the \textbf{ResetHandler} has copied the non-zero initialized data into RAM it calls the \textbf{\_start} function in the C runtime.
The \textbf{\_start} function finds the size of the \textbf{.bss} section which describes the size of zero-initialized area in RAM.
It then calls on the \textbf{memset} function to zero out the RAM.
\textbf{\_start} then goes on to call the \textbf{main} function supplied by the programmer.

\begin{figure}[H]
\begin{verbatim}
// Variables set in linker script
bss_start; // start of .bss segment in RAM
bss_end;   // end of .bss segment in RAM

void _start() {
  memset(bss_start, 0, bss_end - bss_start);
  main(); // User supplied main function
}
\end{verbatim}
\caption{start routine}
\label{fig:start}
\end{figure}

This process is identical in C and in Rust due to the fact that Rust only allows constant initialization before the \textbf{main} function.
In C++ however, the process is complicated by the fact that C++ support static global constructors.
The runtime must therefore be augmented to issue calls to these constructors and handle errors that can occure.

As these processes are identical to C we are able to reuse standard runtime components.
SiliconLabs software suite provides the \textbf{ResetHandler} and linker script for the efm32 microcontrollers.
The \textbf{\_mainCRTStartup} function defined in the C runtime provided by the \textbf{arm-none-eabi} gcc toolchain handles the setup in \textbf{\_start}:

\subsubsection{Minimal Rust program to boot}

There are a few modification which have to be applied to the default 'Hello World' program in order to get it to boot in an embedded environment.
Lets first look at the standard version in Figure \ref{fig:rust-hello-world}.

\begin{figure}[H]
\begin{verbatim}
fn main() {
  println!("Hello, World!");
}
\end{verbatim}
\label{fig:rust-hello-world}
\caption{Rust Hello World}
\end{figure}

In comparrison the embedded version in Figure \ref{fig:embedded-rust-hello-world}.
This program does not print out "Hello, World!"m as this requires some setup and we are conserned with the boot processs here.
The highlight of the changes are, to export the \textbf{main} function to the C runtime, and to prevent the standard library being loaded while retaining the core library.
\begin{figure}[H]
\begin{verbatim}
#![no_std]
#![no_main]
#![feature(lang_items)]

extern crate core;

#[no_mangle]
pub extern "C" fn main() {
  loop {}
}

#[lang="stack_exhausted"] extern fn stack_executed() {}
#[lang="eh_personality"] extern fn eh_personality() {}
#[lang="panic_fmt"] fn panic_fmt() -> ! { loop {} }
\end{verbatim}
\caption{Embedded Hello World}
\label{fig:embedded-rust-hello-world}
\end{figure}

\texttt{\#\![no\_std]} on line 1 in Figure \ref{fig:embedded-rust-hello-world} tells the Rust compiler not to include the standard library.
The standard library is not used for embedded programming. \todo{include reasoning or refere to section about not using std}

Line 2 must be analysed in conjunction with lines 7 and 8.
Firstly we must guarantee that the function can be called by the \textbf{\_start} function.
This is done by defining the \textbf{main} function to be an publicly exported symbol denoted by \texttt{pub extern}. 
Rust symbols are private by default.
The second change is to ensure that the function is callable by the a C function.
\texttt{extern "C"} makes this possible by making the function use the C ABI. \todo{Some reference to the C ABI}
The last thing is to disable the Rust name mangling so that the C code can refere to the function by the unmangled name \textbf{main}.
Now that the \textbf{main} function is altered to be callable by C, the function does not resemble the function the rust compiler expects to find.
Therefore we have to tell the compiler that the program does not contain a \textbf{main} function, but that this is ok, hence the \texttt{\#\![no\_main]}.

The last three lines are a complication due to error handling in Rust.
These functions are used by the core library but implemented in the standard library, they are described in detail in Section \ref{}. \todo{Describe panic and exception handling}
The implementation here just ignores all error handling.

\todo{Might go in a different section}
With an example, we will now see how the startup process maps to the storage qualifiers in Rust.
\begin{figure}[H]
\begin{verbatim}
const      RUST_CONST_ZERO: u32 = 0;      // not allocated
const      RUST_CONST: u32 = 0xFEED;      // not allocated
static     RUST_STATIC_ZERO: u32 = 0;     // .text
static     RUST_STATIC: u32 = 0xDEAD;     // .text
static mut RUST_STATIC_MUT_ZERO: u32 = 0; // .bss
static mut RUST_STATIC_MUT: u32 = 0xBEEF; // .data

pub extern fn main() { /* Use the variables */ }
\end{verbatim}
\caption{Rust static initialization}
\label{fig:rust-static-init}
\end{figure}
In Figure \ref{fig:rust-static-init} the three different types of declaring globals in Rust are shown.
Firstly Rust divides between two types of global declarations, constants and statics.
The static globals are immutable by default but can be made mutable by the \textbf{mut} keyword.
A constant declaration, shown in lines 1 and 2 of Figure \ref{fig:rust-static-init}, represents a value.
There is no need to allocate memory for globals declared as \textbf{const} and they behave like \textbf{\#define} in C. \todo{Well that's a lie as \#define is handled by the preprocessor}
Variables on line 3 and 4 declares the variables to be \textbf{static}.
As these are immutable they are allocated in the read-only section called \textbf{.text}.
The values are read directly from Flash and need not be copied to RAM.
On line 5 and 6 the declarations are marked with \textbf{static mut}.
Here we see that the zero initializes variable is assigned to the \textbf{.bss} section in the \textbf{elf} file.
On line 6 we have a non-zero value that has to be stored in Flash memory prior to execution and is copied to RAM in the \textbf{ResetHandler}.

