\section{Object Oriented Embedded Programming}
\label{sec:back:oo}

The object oriented paradigm has proved to be an effective way to organize computer programs in many different areas.
The paradigm focues on organizing a computer program by looking at the data the program operates on, grouping related data into objects and defining methods that operate on the data contained within the objects.
Rust as a language exposes this paradigm through the language constructs of structs, traits and enum as described in Section \ref{ssub:rust:features}.
The C language does not provide any langauge constructs for dealing with object oriented programming directly, but this does not prevent the paradigm for being used.
\todo{I think we need to mention that the \textbf{state} of objects are important in OO. Its objects with state and functions to read/modify its state}

\subsection{The OO paradigme}
This section introduces the paradigm and shows how to apply it to Rust, C.

\begin{listing}[H]
  \begin{minted}{java}
    class Sensor {
      private int data;

      Sensor() {
        this.data = 0;
      }

      int measure() {
        return this.data;
      }

      static void main(String[] args) {
        Sensor sensor = new Sensor();
        System.out.println(sensor.measure());
      }
    }
  \end{minted}
  \caption{Sensor defined in Java}
  \label{lst:back:oo:java}
\end{listing}

In \autoref{lst:back:oo:java} we define the class Sensor with one private field data, a constructor method to create the object and a measure method to get the sensor data.
In the main function we create an instance of the Sensor, this allocates memory on the heap and saves a reference to the memory on the stack refered to by the  variable called sensor.
Inside the Sensor constructor method the implicit variable this is bound to the reference to the newly allocated heap memory set aside for the Sensor object.
This is done automatically when calling a constructor method with the keyword new.
With the this variable we can refere to the objects fields and methods.
When we hold a reference to an object as the sensor variable in the main method we can apply the methods of the object on the reference with the method call syntax.
This causes the this variable in the method to be bound to the reference to the object the method is applied to.

\begin{listing}[H]
  \begin{minted}{rust}
    struct Sensor {
      data: u32
    }

    impl Sensor {

      fn new() -> Sensor {
        Sensor { data: 0 }
      }

      fn measure(&self) -> u32 {
        self.data
      }
    }

    fn main() {
      let s1 = Sensor::new();
      println!("{}", s1.measure());

      let s2 = Box::new(Sensor::new());
      println!("{}", s2.measure());
    }
  \end{minted}
  \caption{Sensor defined in Rust}
  \label{lst:back:oo:rust}
\end{listing}

The object oriented pattern has special syntax in Rust.
As \autoref{lst:back:oo:rust} shows, we create the Class definition by using a struct for specifing the data fields and an impl for implementing the methods.
Rust does not define special mechanism for constructing objects.
The object construction pattern shown in \autoref{lst:back:oo:rust}, is simply the ideomatic way to add a constructor to a object.
But the programmer is free to for instance return a reference to the created object if it is more suitable.
The new method in \autoref{lst:back:oo:rust} is flexible enough to create both stack allocated and heap allocated objects of the Sensor type.
This is shown in the main method where s1 is allocated on the stack while s2 is allocated on the heap.
The Box::new function allocates heap memory in Rust.
When the method measure is called on the reference to the object the self variable is bound to the reference.
This is analogous to the this variable in \autoref{lst:back:oo:java}.
The self parameter appears explicit in the method signature and is here in the for of an immutable reference.
The self parameter can be either a direct variable, an immutable reference or a mutable reference in Rust.

\begin{listing}[H]
  \begin{minted}{rust}
    typedef struct {
      uint32_t data;
    } Sensor;

    void Sensor_New(Sensor *self) {
      self->data = 0;
    }

    uint32_t Sensor_Measure(Sensor *self) {
      return self.data;
    }

    int main() {

      Sensor s1;
      Sensor_New(&s1);
      printf("%d\n", Sensor_Measure(&s1));

      Sensor* s2 = (Sensor*)malloc(sizeof(Sensor));
      Sensor_New(s2);
      printf("%d\n", Sensor_Measure(s2));
      free(s2);

      return 0;
    }
  \end{minted}
  \caption{Sensor defined in C}
  \label{lst:back:oo:c}
\end{listing}

C does not provide any syntax for dealing with method calls on objects, but the object oriented paradigm can be used through convention.
\autoref{lst:back:oo:c} shows a definiton for a Sensor class with constructor function and member function in the C programming language.
Here we see the method call mechanism explicit in the main function where the a reference to the object has to be passed explicit as the first argument.
Memory allocation is also handled explicit through malloc when allocating a object on the heap.
The pattern can be changed to expose a New function that returns a reference to a heap allocated object, but this either prevents stack allocated objects or leads to alot of to to handle it.
The main function also contains a explicit free of the heap allocated memory which is not present in \autoref{lst:back:oo:rust}.
This is due to the ownership rules of Rust explained in \autoref{sec:back:rust:own}.

\subsection{Object Oriented Hardware components}

In the previous section we saw how the OO-paradigm is implemented in Java, Rust and C.
We can see that in essence the paradigm consists of a datatype with a number of fields, a collection of function that operates on the fields given a reference to a object of this datatype.
This paradigm can be directly applied to software components in a embedded system such as a circular buffer.

Hardware components in a embedded system as the Gecko Mircocontroller are often exposed as memory mapped devices.
This implies for instance that the control registers for a devices such as an Analog-To-Digital is located in the address space of the CPU and can be read from and written to with the same instruction and language constructs as the rest of the memory.
\autoref{fig:back:memorymapped} shows the control registers for the device which are placed continuously in memory.

\begin{figure}[H]
  \centering
  \begin{tabular}{l|l|l|}
    &&\\
    \hline
    Location&Offset&Name\\
    \hline
    0x40002000&0x0&CTRL\\
    \hline
    &0x4&CMD\\
    \hline
    &0x8&STATUS\\
    \hline
    &...&... \\
    \hline
    &0x3C&BIASPROG\\
    \hline
    &&\\

  \end{tabular}
  \caption{ADC0 Memory map for EFM32GG}
  \label{tab:back:memorymapped}
\end{figure}

\autoref{fig:back:objectmemory} shows the memory layout for the objects defined in \autoref{sec:back:oo}.
We see that the difference between the Java managed language and the C and Rust system langauges is the tag field preciding the data fields for the object.
\begin{figure}[H]

  \centering
  \subfloat[Java]{
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|l|}{Sensor} \\
      \hline \hline
      0x0&Object tag \\
      \hline
      0x4&data\\
      \hline
    \end{tabular}
    \label{fig:back:memlayout:java}
  }
  \hfill
  \subfloat[Rust]{
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|l|}{Sensor} \\
      \hline \hline
      0x0&data\\
      \hline
    \end{tabular}
    \label{fig:back:memlayout:rust}
  }
  \hfill
  \subfloat[C]{
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|l|}{Sensor} \\
      \hline \hline
      0x0&data\\
      \hline
    \end{tabular}
    \label{fig:back:memlayout:c}
  }
  \caption{Memory layout of objects}
  \label{fig:back:memlayout}

\end{figure}

And the control registers can be modified thru fields and member methods.

In order to do so we need to modify the object story defined above.
In the usual object oriented case the object is created, used, passed around and deallocated.
Each time we create a new object it is either allocated on the current stack frame or at som arbirary heap location.
This does not hold true for a memory mapped hardware device.
The device does not have to be allocated or deallocated, its lifetime is static and exists from the program starts executing on the microcontroller.
Instead of a constructor function we need a way to get a reference to the memory mapped device.
\todo{Also mention that the peripherals still need to initialized, even though  they are memory mapped. They need clocks etc....}
