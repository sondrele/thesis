% !TEX root = ../main.tex

\chapter{Conclusion}
\label{chap:conclusion}

In this thesis we have presented the {\rg} platform for embedded programming using the {\rust} programming language.
We have seen that the platform makes use of many of the language and community features which comes with a modern programming language.
From our measured results we showed that by using this {\rust} based platform, we can still make applications which perform the equally well as the exisiting {\C} platform.
Still we did find evidence of the platform prducing larger binaries, which makes {\rust} application more expensive, in terms of hardware choises, or renders them useless for the most resource constrained applications.
We have also seen that there does exist some obsticales for making use of the convenient ways of sharing code between projects, although the basic mechanims still work.


\section{Future work}
\label{chap:future}

As we presented in \autoref{sub:interfacing_with_emlib} the platform consists of partialy finished bindings.
An obvious extension to our project is to continue and finialize the binding libraries for the {\emlib}, {\emdrv} and {\cmsis} libraries.
The foundations for these binding have been layed out, so the implementation here is not challening, only timeconsuming.
An alternative approach is to use a bindings generator such as \lib{bind-gen} \footnote{} to generate the binding automatically.
This effort might also be redundant altogether, as the {\rust} roadmap states that the project wants to develop better integration with {\C}/{\Cpp} code.
This might evidentually lead to bindings like these being made obsolite, and that {\C} libraries can called into based on their header files, alone.

In \autoref{sec:rust-embedded-modules} we looked at a library which provided higher level abstraction using the langauge features of {\rust}.

The interrupted programming model used to program embedded system did not prove to be as applicable to {\rust} as we had hoped.
In \autoref{sec:impl:irq-closures} we looked at a technique for changing this model by using ownership rules similar to how concurrency is handled in {\rust}.
This library has potential to provide a more idiomatic programming style to embedded programs in {\rust} and will make the platform more familiar to {\rust} developers.
This library can be extended to control the ownership of \glspl{mmio} as discussed in \autoref{sec:ownership_allied_to_hardware}.

In the \autoref{sec:disc:project_evaluations} we argued that in order to make a more thoroughly comparision of the {\C} and {\rust} languages in this domain, more of the platform has to be implemented in {\rust}.
On possible way to do this is to start this project from scratch by using the \lib{zinc.rs} framework and porting the actual implementations of the {\emlib} library to {\rust}.
In doing so, the examples provided with {\emlib} can be used as a benchmark suite to compare the two platforms.
This can both provide a better basis for evaluation, but can also, as we showed in \autoref{sec:porting-gpioint}, uncover bugs in the {\C} implementation of {\emlib}.
These discoveries can help motivate the usage of {\rust} in this domain.
Thoughout this thesis we have only worked with the {\rust} language as the application layer language and binding to {\C}, there is no problem with doing it the other way around.
Therefore parts of the {\emlib} library can actually be replaced with {\rust} code and still expose the same \gls{api} to the user.
