% !TEX root = ../main.tex

\chapter{Conclusion}
\label{chap:conclusion}

In this chapter we draw conclusions derived from the discussion of the {\rg} platform.
We also look back at the requirements that was defined in \autoref{chap:intro} and give an evaluation of success for the project.
Finally, we give our thoughts on further developments to improve the {\rg} platform, and suggest some changes that could make {\rust} more suited for embedded systems.

\section{The RustyGecko Platform}

In this thesis, we have presented the {\rg} platform for embedded programming using the {\rust} programming language.
This platform consists of a subset of the {\rust} standard library and a handful of libraries that defines bindings for the EFM32 peripheral \gls{api}.
In total, we have been able to utilize many great aspects that surround the {\rust} programming language in the {\rg} platform.

One of the tools we were able to incorporate is the {\cargo} package manager.
This enabled us to give the {\rg} platform a modular design, which makes the different parts of the platform reusable as isolated units of code.
However, the \gls{rsl} is an implied dependency for all standard {\rust} projects.
Because of this, and given the current design of \gls{rsl}, it is hard for non-standard projects to utilize third-party libraries.

{\rust} implements many interesting features, among these, is its ability to statically prevent data-races.
We attempted to apply these concepts directly to the hardware peripherals but found the resulting programming model to be too limited.
Instead, we propose to explore this idea further by considering a more dynamic approach as future work.

From our measured results, we showed that on the {\rg} platform we can still make applications which perform as well as the existing {\C} platform.
This conclusion is derived from our qualitative study of performance and energy consumption for the two applications that was developed on this platform.
However, we did find indications that the platform produces larger binaries, which makes {\rust} applications more expensive in terms of hardware costs.
The binaries are stored in flash memory and the size of this memory correlates with the cost of the microcontroller.
The increased cost in hardware can be expensive for resource constrained applications which are shipped in the millions.
This simple fact can turn out to be a deal-breaker for applications in the industry.

\section{Requirements}

In \autoref{chap:intro} we presented three requirements as interpreted from the Project Description for this thesis.
Requirement \textbf{R1} is achieved through the presentation of the existing {\C} platform, given in \autoref{chap:background}, in comparison to the {\rust} platform that was presented throughout the core chapters.
\autoref{sec:disc:lang-challenges} covered the language challenges discussed in \autoref{sec:intro:assignment}, as part of requirement \textbf{R1}, and shows that each challenge is considered in the {\rg} platform.
We therefore conclude that these challenges are solved for using {\rust} in an embedded system.
Further we consider the {\rg} platform to fulfill requirement \textbf{R2}.
Throughout \autoref{chap:results} we presented our results of measuring the {\rg} platform and our evaluation of the measurements are given in \autoref{chap:discussion} to satisfy requirement \textbf{R3}.

\section{Future work}
\label{chap:future}

As we presented in \autoref{sub:interfacing_with_emlib} the platform consists of partially finished bindings.
An obvious extension to our project is to continue and finalize the binding libraries for the {\emlib}, {\emdrv} and \gls{cmsis} libraries.
The foundations for these binding have been laid out, so the implementations here are not challenging, only time-consuming.
An alternative approach is to use a bindings generator such as \lib{bindgen}\footnote{\url{https://crates.io/crates/bindgen}} to generate the binding automatically.
The binding effort might be redundant altogether, as the {\rust} roadmap \cite{web:roadmap} states that the project wants to develop better integration with {\C}/{\Cpp} code.
This might eventually lead to bindings like these being made obsolete, and that {\C} libraries can called into based on their header files, alone.

In \autoref{sec:rust-embedded-modules} we looked at a library which provided higher level abstraction using the language features of {\rust}.

The interrupt-driven programming model used to program embedded system did not prove to be as applicable to {\rust} as we had hoped.
In \autoref{sec:irq-closures} we looked at a technique for changing this model by using ownership rules similar to how concurrency is handled in {\rust}.
This library has potential to provide a more idiomatic programming style to embedded programs in {\rust} and will make the platform more familiar to {\rust} developers.
This library can be extended to control the ownership of \glspl{mmio} as discussed in \autoref{sec:ownership_allied_to_hardware}.

In the \autoref{sec:disc:project_evaluations} we argued that in order to make a more thoroughly comparison of the {\C} and {\rust} languages in this domain, more of the platform has to be implemented in {\rust}.
On possible way to do this is to start this project from scratch by using the \lib{zinc.rs} framework and porting the actual implementations of the {\emlib} library to {\rust}.
In doing so, the examples provided with {\emlib} can be used as a benchmark suite to compare the two platforms.
This can both provide a better basis for evaluation, but can also, as we showed in \autoref{sec:porting-gpioint}, uncover bugs in the {\C} implementation of {\emlib}.
These discoveries can help motivate the usage of {\rust} in this domain.
Throughout this thesis we have only worked with the {\rust} language as the application layer language and binding to {\C}, it is possible to do this the other way around.
Therefore parts of the {\emlib} library can actually be replaced by an {\rust} implementation and still expose the same \gls{api} to the user.
