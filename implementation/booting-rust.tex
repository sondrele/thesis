\section{Booting Rust on the Gecko}
\label{sec:impl:booting}

The contents of this section explains how the startup process described in \autoref{sec:back:startup} is implemented for a {\rust} program.

The process for {\rust} is identical to the process in {\C} due to the fact that {\rust} only allows constant initialization before the {\main} function.
In C++ however, the process is complicated by the fact that C++ supports static global constructors as shown in \autoref{lst:impl:c++:static-constructor}

\begin{listing}[H]
  \begin{minted}{c++}
class Foo { Foo() { } };
Foo foo; // statically called constructor
int main() { return 0; }
  \end{minted}
  \caption{C++ with static constructor call}
  \label{lst:impl:c++:static-constructor}
\end{listing}

In \autoref{lst:impl:c++:static-constructor} the Foo constructor call must be issued before the main function is executed.
The runtime must therefore be augmented to issue calls to these constructors and handle errors that can occur.
These types of constructors are not allowed in {\rust} by a compiler rule which allows only constant-expression as initializers.
(An interesting side note here is given in \autoref{sec:impl:lazy-statics}.)

As this process is identical to {\C} we are able to reuse standard runtime components for embedded toolchains for {\C}.
SiliconLabs software suite provides the \func{ResetHandler} and linker script for the efm32 microcontrollers.
The \func{\_mainCRTStartup} function defined in the {\C} runtime provided by the \textbf{arm-none-eabi} gcc toolchain handles the setup in \func{\_start} described in \autoref{lst:start}.

\subsection{Minimal Rust program to boot}

There are a few modification which have to be applied to the default `Hello World' program in order to get it to boot in an embedded environment.
Let us first look at the standard version in \autoref{lst:rust-hello-world}.

\begin{listing}[H]
  \begin{minted}{rust}
fn main() {
  println!("Hello, World!");
}
  \end{minted}
  \caption{Rust Hello World}
  \label{lst:rust-hello-world}
\end{listing}

A {\rust} program will by default include \gls{RSL} automatically.
As explained in \autoref{sec:rsl}, this library is not usable in an embedded program and some the changes to the `Hello World' program mostly deals with removing the \gls{RSL}.

The embedded `Hello World' program, as given in \autoref{lst:embedded-rust-hello-world} does not print out "Hello, World!", as this requires irrelevant setup as we are conserned with only the boot process here.
In addition to removing the \gls{RCL}, the {\main} function is \emph{exported} to be callable from the {\C} runtime.

\begin{listing}[H]
  \begin{minted}{rust}

// Annotations
#![no_std]
#![no_main]
#![feature(lang_items)]

// Crate import
extern crate core;

// Define main function
#[no_mangle]
pub extern "C" fn main() {
  loop {}
}

// Define three functions which are needed by core but defined in std
#[lang="stack_exhausted"] extern fn stack_executed() {}
#[lang="eh_personality"] extern fn eh_personality() {}
#[lang="panic_fmt"] fn panic_fmt() -> ! { loop {} }
\end{minted}
\caption{Embedded Hello World in Rust}
\label{lst:embedded-rust-hello-world}
\end{listing}

\attrib{\#\![no\_std]} on line 1 in \autoref{lst:embedded-rust-hello-world} tells the {\rust} compiler not to include the standard library.

Line 2 must be analysed in conjunction with lines 7 and 8.
Firstly we must guarantee that the function can be called by the \func{\_start} function.
This is done by defining the {\main} function to be an publicly exported symbol denoted by \code{pub extern}.
{\rust} symbols are private by default.
The second change is to ensure that the function is callable by the a {\C} function.
\code{extern "C"} makes this possible by making the function use the {\C} ABI. \todo{Some reference to the {\C} ABI}
The last thing is to disable the {\rust} name mangling so that the {\C} code can refere to the function by the unmangled name {\main}.
Now that the {\main} function is altered to be callable by C, the function does not resemble the function the rust compiler expects to find.
Therefore we have to tell the compiler that the program does not contain a {\main} function, but that this is ok, hence the \attrib{\#\![no\_main]}.

The last three lines are a complication due to error handling in {\rust}.
These functions are used by the core library but implemented in the standard library.
The implementation here just ignores all error handling.

\todo{Might go in a different section}

\subsection{Storage qualifiers}

As described in \autoref{sec:back:startup} the startup procedure initializes all global variables.
In this section we look at how each storage qualifier,  applicable to global variables in {\rust}, map to different sections of the {\elf} binary.

\begin{listing}[H]
\begin{minted}{rust}
const      RUST_CONST_ZERO: u32 = 0;      // not allocated
const      RUST_CONST: u32 = 0xFEED;      // not allocated
static     RUST_STATIC_ZERO: u32 = 0;     // .text
static     RUST_STATIC: u32 = 0xDEAD;     // .text
static mut RUST_STATIC_MUT_ZERO: u32 = 0; // .bss
static mut RUST_STATIC_MUT: u32 = 0xBEEF; // .data

pub extern fn main() { /* Use the variables */ }
\end{minted}
\caption{Rust static initialization}
\label{lst:rust-static-init}
\end{listing}
In \autoref{lst:rust-static-init}, the three different types of declaring globals in {\rust} are shown.
{\rust} divides between two types of global declarations, constants and statics.

A constant declaration, shown in lines 1 and 2 of \autoref{lst:rust-static-init}, represents a value.
There is no need to allocate memory for globals declared as \code{const} as the values can be directly inserted where they are used by the compiler.

The static globals are immutable by default but can be made mutable by the \code{mut} keyword.
The variables on line 3 and 4 are declared to be \code{static}.
As these are immutable they are allocated in the read-only section called \elfsec{.text}.

On line 5 and 6 the declarations are marked with \code{static mut}.
Here we see that the zero initializes variable is assigned to the \elfsec{.bss} section in the {\elf} file.
On line 6 we have a non-zero value that has to be stored in Flash memory prior to execution and is copied to RAM in the \func{ResetHandler}.

\subsection{Bootstrapping startup}
\label{sec:startup}

The Rust program presented in \autoref{lst:embedded-rust-hello-world} is quite obscure.
For this reason the \lib{startup} crate was developed to minimize the effort to make a simple program and to contain the details.

A minimal `Hello World' program using the \lib{startup} crate is given in \autoref{lst:embedded-rust-bootstrapped}.

\begin{listing}[H]
  \begin{minted}{rust}
#![no_std]
#![feature(no_std)]

extern crate startup;

fn main() {

    loop {}
}
  \end{minted}
  \caption{Embedded Hello World using startup library to bootstrap}
  \label{lst:embedded-rust-bootstrapped}
\end{listing}
