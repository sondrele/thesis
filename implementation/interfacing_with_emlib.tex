% !TEX root = ../main.tex

\section{Bindings for emlib}
\label{sub:interfacing_with_emlib}

The \gls{ffi} available in \rust has been used to interface with Silabs' emlib.
This way, we have been able to create thin wrappers around the \gls{api} for the different peripherals that we have used in the project, without porting the core logic itself.
The following sections explains the process of defining and implementing the \gls{ffi} in \rust that is used to access and control the peripherals on the \texttt{Gecko}.
We will start by showing an example of what it is like to use Silab's emlib (with C), and then move on to what it looks like to use the bindings in \rust.

\subsection{Defining the Bindings}

The \texttt{Timer} peripheral \cite{an0014_timer} works as a good example to demonstrate what the \rust bindings look like.
The module is fairly small, it mostly exposes functions to set up and initialize four different timers that can be used for up, down, up/down, and input- and output-capture.
The program shown in \autoref{lst:timer_program_c} is an example of initializing the \texttt{Timer0} peripheral on the \texttt{Gecko}, note that this is not a complete working example, it only shows the most important parts required to use the Timer module.
First, in order to use a peripheral, its clock need to be enabled.
Every external clock are disabled by default \todo{Is this true? Is every clock disabled?} in order for the peripherals not to draw any power, by enabling the clock the \gls{mcu} will get access to control it.
Then an initialization structure for the Timer module is acquired, this structure has fields to configure many different properties of the Timer, in the same way as described in \autoref{ssec:memory_mapped_io}.

\begin{listing}[h]
\begin{minted}{c}
// Enable clock for TIMER0 module
CMU_ClockEnable(cmuClock_TIMER0, true);
// Select TIMER0 parameters
TIMER_Init_TypeDef timerInit = TIMER_INIT_DEFAULT;
// Enable overflow interrupt
TIMER_IntEnable(TIMER0, TIMER_IF_OF);
// Enable TIMER0 interrupt vector in NVIC
NVIC_EnableIRQ(TIMER0_IRQn);
// Set TIMER Top value
TIMER_TopSet(TIMER0, TOP);
// Configure TIMER
TIMER_Init(TIMER0, &timerInit);
\end{minted}
\caption{Initializing a Timer in C}
\label{lst:timer_program_c}
\end{listing}

The next lines enables interrupts for the Timer, and the NVIC interrupt vector is set up to call the function shown in \autoref{lst:timer_interrupt_handler} every time an interrupt it triggered by the Timer.
All this function does is to clear the interrupt signal and toggle the value of an LED.
We can imagine an application where the Timer is configured to trigger an interrupt every minute to toggle the LED, and in between the interrupts the \gls{mcu} can be put to sleep in order to save power.
Interrupts like this are an important part of programming the \texttt{Gecko}.
They can be used for an asynchronous programming model where the application is defined by the code in the different interrupt handlers, and like in the example above, the \gls{mcu} can be put to sleep in between interrupts.

\begin{listing}[h]
\begin{minted}{c}
void TIMER0_IRQHandler(void) {
  // Clear flag for TIMER0 overflow interrupt
  TIMER_IntClear(TIMER0, TIMER_IF_OF);
  // Toggle LED ON/OFF
  GPIO_PinOutToggle(LED_PORT, LED_PIN);
}
\end{minted}
\caption{Timer Interrupt Handler}
\label{lst:timer_interrupt_handler}
\end{listing}

The equivalent program written in \rust is shown in \autoref{lst:timer_program_rust}.
Semantically they are the same, but the usage differs slightly, which is natural since we are using a higher level programming language.
Instead of calling functions that are included through a C header file, we are calling functions that are available through a \rust module.
For example, the \texttt{Clock} enum is part of the \texttt{cmu} module, and the \texttt{enable\_irq} function is part of the \texttt{nvic} module.
This modularization of peripherals can help to make the code less verbose by partially including modules.
It is also worth to notice the difference between how the \texttt{Timer0} structure can be treated like an object with its own member methods in \rust, instead of being passed as the first parameter to every function that requires it, like in C.

\begin{listing}[h]
\begin{minted}{rust}
// Enable clock for TIMER0 module
cmu::clock_enable(cmu::Clock::TIMER0, true);
// Select TIMER0 parameters
let timer_init = Default::default();
// Enable overflow interrupt
let timer0 = timer::Timer::timer0();
timer0.int_enable(timer::TIMER_IF_OF);
// Enable TIMER0 interrupt vector in NVIC
nvic::enable_irq(nvic::IRQn::TIMER0);
// Set TIMER Top value
timer0.top_set(TOP);
// Configure TIMER
timer0.init(&timer_init);
\end{minted}
\caption{Initializing a Timer in \rust}
\label{lst:timer_program_rust}
\end{listing}

\subsection{Exposing Static Inline Functions to \rust}

In order to work with structures and enums originally defined in C, we had to redefine them in \rust and mark them with \texttt{\#[repr(C)]} so that \rust can guarantee that the data-elements are C compatible.
The header files in the peripheral \gls{api} also defines many functions as \texttt{static inline}, which only make the functions accessible by including the header file.
Since it is not possible to include C header files directly in \rust, we had to expose these functions through one extra layer of C code.
As an example, the \texttt{TIMER\_IntEnable} function is defined as \texttt{static inline} in \texttt{em\_timer.h}, in order to call this function through \rust we had to expose it through the file \texttt{timer.c}, as shown in \autoref{lst:exposing_static_inline}.

\begin{listing}[h]
\begin{minted}{c}
#include "en_timer.h"

void STATIC_INLINE_TIMER_IntEnable(TIMER_TypeDef *timer,
                                   uint32_t flags) {
    TIMER_IntEnable(timer, flags);
}
\end{minted}
\caption{Exposing a \texttt{static inline} function to \rust.}
\label{lst:exposing_static_inline}
\end{listing}

In the \rust module definition of Timer, the function has to be made available through the \texttt{extern} block shown in \autoref{lst:rust_ffi_example}.
As described in \autoref{ssub:unsafe_code}, every function available through the \gls{ffi} are considered \texttt{unsafe} because \rust knows nothing about the function, other than its parameters and its return value.
Thus, in order to make it practical to use the library in a seemingly safe manner, we wrap the calls to the foreign functions in an \texttt{unsafe} block, in the respective function defined in \rust.

\begin{listing}[h]
\begin{minted}{rust}
impl Timer {
    pub fn int_enable(&self, flags: u32) {
        unsafe { STATIC_INLINE_TIMER_IntEnable(self, flags)}
    }
}

extern {
    fn STATIC_INLINE_TIMER_IntEnable(timer: &Timer, flags: u32);
}
\end{minted}
\caption{Defining and using a function through the \rust \gls{ffi}.}
\label{lst:rust_ffi_example}
\end{listing}

If we compare the call-stacks between calling the \texttt{timer0.int\_enable} function in \rust and calling the \texttt{TIMER\_IntEnable} function in C, we can see that every function call through the \gls{ffi} requires \emph{two} extra function calls.
These are simple wrappers which require extra unconditional jumps in the code, and performance-wise it is a very unnecessary overhead to have one to two extra stack frames allocated for \emph{every} function call through the \gls{ffi}.
By compiling the code with optimization, \rust will get rid of the overhead introduced by the function that wraps around the call to the foreign function.
Additionally, by enabling \emph{link-time-optimizations} during the compilations, LLVM will remove the overhead entirely, which results in the same performance and similar call-stacks between C and \rust.
This is a working example of one of \rust's many zero-cost abstractions.

\subsection{Naming Conventions}

We have tried to keep \texttt{emlib}'s naming convention across the layer of bindings.
This makes it easy for anyone reading either the C- or the \rust-code to translate and understand the code between the two languages.
Since every constant, enum-field, or struct-name is directly accessible by name in C, if the corresponding header file is included, it is important that names of such fields can be separated from each other and do not cause a naming collision.

\begin{listing}[h]
\begin{minted}{c}
typedef enum {
  timerCCModeOff     = _TIMER_CC_CTRL_MODE_OFF,
  timerCCModeCapture = _TIMER_CC_CTRL_MODE_INPUTCAPTURE,
  // ...
} TIMER_CCMode_TypeDef;
\end{minted}
\caption{Part of a Timer enum defined in C.}
\label{lst:enum_naming_c}
\end{listing}

As an example, two fields of an enum from \texttt{em\_timer.h} is shown in \autoref{lst:enum_naming_c}.
From each field in the enum we can extract 1) its module name \texttt{timer}, 2) its typedef name \texttt{CCMode} and 3) its field name \texttt{Off} or \texttt{Capture}.
\rust allows us to keep the same naming convention at the same time as utilizing its modularity.
\autoref{lst:enum_naming_rust} shows the enum ported to \rust, where both the module name and the typedef name has been left out, and only the field names have remained.
However, the naming convention remains the same when the fields are used, e.g. the expression ``\texttt{let mode = timer::CCMode::Capture;}'' in \rust shows the similarity with the equivalent expression in C: ``\texttt{int mode = timerCCModeCapture;}''.

\begin{listing}[h]
\begin{minted}{rust}
pub enum CCMode {
  Off     = _TIMER_CC_CTRL_MODE_OFF,
  Capture = _TIMER_CC_CTRL_MODE_INPUTCAPTURE,
  // ...
}
\end{minted}
\caption{The enum ported to \rust.}
\label{lst:enum_naming_rust}
\end{listing}

\subsection{Testing}
\label{ssub:testing}

\todo{HÃ¥vard: Tar du denne seksjonen?}

\subsection{Thoughts and Review}

\todo{Does it make sense to have this section here? Should content like this be mover somewhere else (like in the discussion chapter), or is this a good place?}

Writing the bindings for different the peripherals was a tedious work, that required careful review of the \texttt{emlib} source code in order to correctly port enum- and struct-definitions from C to \rust.
Additionally, we had to redefine many constants, like the names of memory-mapped register bit-fields like the ones presented earlier in \autoref{fig:back:memorymapped}, or values calculated from various C macros defined in header files that are used throughout the library.
We had to retrieve the value of the constants by debugging the source code and explicitly look up the value of these constants if they were only implicitly defined in the header files.

Since we have constrained our library to only support the EFM32GG990 devices we chose to manually write the bindings for the library, instead of generating the bindings through some kind of automated process.
There were already a couple of tools available for generating such C-bindings automatically, that could possibly have made the process quicker.
However, we chose not to utilize such tools because of the reasons described below.

\begin{itemize}
    \item It was quick and easy to get started with code for a new peripheral.
    This argument was especially important when the project started out, because we still had no clue of how the project would evolve and what it was going to look like.

    \item It was an advantage to depend on as few third party tools as possible, since both \rust and all available libraries would be unstable until the 1.0 release of the language.

    \item We wanted to keep the naming convention of our bindings as similar to \texttt{emlib} as possible, this would not have been easy to keep consistent with an automated process, partly because there are exceptions where these conventions do not fully hold.
    It is however an interesting problem that would have a higher priority if the library were ever to support more than one EFM32 device.

    \item We could focus on writing bindings for smaller parts of each module separately when we first needed them, which would split the work into smaller work-packages.
\end{itemize}
