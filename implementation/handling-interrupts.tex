\subsection{Handling Interrupts in Rust}
\label{sec:impl:handling-interrupts}

Interrupts are an integral part of embedded programs and having a native way of handling the interrupts provides a great benefit and flexibility for a programming language.

To handle interrupts on the Gecko one have to register a function in the interrupt vector.
This vector is defined in the \textbf{startup} file provided by SiliconLabs and is simply a list of function pointers defined in the \textbf{.isr\_vector} section of the \textbf{elf} binary.
This section is the first section in the \textbf{text} segment of the binary which ensures that it is located at address 0 when the microcontroller starts executing.
When an interrupt occures the microcontroller will inspect the interrupt vector and find the address of the handler function for the interrupt which occured.
On the Gecko both the interrupt vector and the default interrupt hanlders are defined in the \textbf{startup} file.
The default implementations are simply infinte loops defined as weak symbols.
These weak symbols allows the programmar to redefine the symbol elsewhere to override this default implementation.

\autoref{lst:c:irq} shows how the \textbf{SysTick\_Handler} is overriden in C.

\begin{listing}[H]
  \begin{minted}{c}
void SysTick_Handler(void) {
  // Handler code
}
  \end{minted}
  \caption{SysTick Interrupt Handler in C}
  \label{lst:c:irq}
\end{listing}

Defining an interrupt handler in Rust is just as easy as in C because of the focus on interoptablity with C code.
In Rust a function can easly be defined to use the C ABI required to be called as an interrupt handler.
\autoref{lst:rust:irq} gives the Rust version of the \textbf{SysTick\_Handler} override.

\begin{listing}[H]
  \begin{minted}{rust}
#[no_mangle] pub extern fn SysTick_Hanlder() {
  // Handler code
}
  \end{minted}
  \caption{SysTick Interrupt Handler in Rust}
  \label{lst:rust:irq}
\end{listing}
