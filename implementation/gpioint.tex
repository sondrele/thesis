% !TEX root = ../main.tex

\section{Porting GPIO Interrupt Driver}
\label{sec:porting-gpioint}

This section considers a case-study of an issue in the {\emdrv} library, and it was discovered while we ported the \gls{gpio} interrupt driver from {\C} to {\rust}.
This driver was ported to {\rust} because we wanted to issue \gls{gpio} interrupts with {\rust} function pointers, without needing to declare them with the {\C} \gls{abi} (which was required by {\emdrv}).
The issue was discovered when annotating the \texttt{unsafe} blocks for referencing mutable global state, and gives an example of the awareness the inclusion of the {\unsafe} keyword provides.

\subsection{Presenting the Problem}

The \texttt{gpioint} driver lets the user register a callback function to be called when an interrupt occurs at a given \gls{gpio} pin.
It is implemented with a global mutable list of 16 function pointers, a register function to assign functions to indices of the list corresponding to the \gls{gpio} pins, and a dispatch mechanisms which calls the correct functions when an interrupt occurs.
The issue arises in the dispatch function in \autoref{lst:irq-dispatch:c}.

\begin{listing}
  \begin{ccode}
static void GPIOINT_IRQDispatcher(uint32_t iflags) {
  while(iflags) {
    // Utility for iterating through all active interrupt signals
    uint32_t irqIdx = GPIOINT_MASK2IDX(iflags);
    // Mark interrupt as handled
    iflags &= ~(1 << irqIdx);
    // Check if the interrupt has a callback
    if (gpioCallbacks[irqIdx]) {
      // Call the callback
      gpioCallbacks[irqIdx](irqIdx);
    }
  }
}
  \end{ccode}
  \caption{GPIO Dispatcher from {\emlib}}
  \label{lst:irq-dispatch:c}
\end{listing}

\begin{listing}
  \begin{rustcode}
static mut GPIO_CALLBACKS: [Option<Fn(u8)>; 16] = [None; 16];

fn dispatcher(iflags: u32) {
  while(iflags) {
    // Utility for iterating through all active interrupt signals
    let irq_idx = mask_to_index(iflags);
    // Mark interrupt as handled
    iflags &= !(1 << irq_idx);
    // Check if the interrupt has a callback
    if (unsafe { GPIO_CALLBACKS[irq_idx] }.is_some()) {
      // Window of opportunity

      // Unwrap the callback and call the function
      unsafe { GPIO_CALLBACKS[irq_idx] }.unwrap()(irq_idx);
    }
  }
}
  \end{rustcode}
  \caption{GPIO Dispatcher naively ported to {\rust}}
  \label{lst:irq-dispatch:rust}
\end{listing}

A first take at porting the dispatcher function to {\rust} yields the code in \autoref{lst:irq-dispatch:rust}.
It is quite easy to see that the mutable global state is read twice exposed by the compiler requirement to include the {\unsafe} keyword (lines 10 and 15).
This means that there is a possibility of the second reference to return a different value than the first.
For instance, the function \func{GPIOINT\_CallbackUnRegister(uin32\_t pin)} will set the function pointer in the array to \mem{0x0} for the specified pin.
If this function is called inside an interrupt handler, and this interrupt is triggered while the GPIO driver is dispatching an interrupt, the function pointer can be set to \mem{0x0} between the check (at line 10) and the call (at line 15).
Calling a function pointer that points to \mem{0x0} will cause a \func{HardFault}.

\subsection{Analysis of Assembly}
To dive a bit further into the issue and to prove that it is only present at optimization level O0 we consider the assembly code, generated by compiling the {\C} source, for the dispatcher function.
The subsection of the \func{GPIOINT\_IRQDispatcher} in assembly generated by \prog{arm-none-eabi-gcc -O0 -S} is reproduced in \autoref{lst:gpio:asm:O0}.

\begin{listing}[H]
  \begin{ca65code}
GPIOINT_IRQDispatcher:
  ;; ...                    ;;
  ldr r3, .L34              ;; r3 = gpioCallbacks
  ldr r2, [fp, #-8]         ;; r2 = irqIdx
  ldr r3, [r3, r2, asl #2]  ;; r3 = gpioCallbacks[irqIdx]
; start interrupt window    ;;
  cmp r3, #0                ;; if (r3 == 0) {
  beq .L30                  ;;
  ldr r3, .L34              ;;   r3 = gpioCallbacks
  ldr r2, [fp, #-8]         ;;   r2 = irqIdx
; end interrupt window      ;;
  ldr r3, [r3, r2, asl #2]  ;;   r3 = gpioCallbacks[irqIdx]
  ;; ...                    ;;
  bx  r3                    ;;   (*r3)();  call the function
  ;; ...                    ;; }
  \end{ca65code}
  \caption{GPIOINT Dispatcher in assembly with O0}
  \label{lst:gpio:asm:O0}
\end{listing}

Here we see a window of 4 instructions where the proposed harmful interrupt can occur.
It is the \func{ldr} instruction just before the window opening and the one just after that causes the issue.
These two loads must load the same address for the logic to be valid, although the second one is just required to not load \mem{0x0} in order not to cause a \func{HardFault}.
If we look at the same assembly generated by compiling the code with \prog{arm-none-eabi-gcc -O1 -S} in \autoref{lst:gpio:asm:O1}, we see that the issue has been eliminated.

\begin{listing}[H]
  \begin{ca65code}
GPIOINT_IRQDispatcher:
  ;; ...                    ;;
  ldr r5, .L5               ;; r5 = gpioCallbacks
  ;; ...                    ;;
  and r3, r0, #255          ;; r3 = irqIdx
  ;; ...                    ;;
  ldr r3, [r5, r3, asl #2]  ;; r3 = gpioCallbacks[irqIdx]
  cmp r3, #0                ;; if (r3 == 0) {
  ;; ...                    ;;
  bxne    r3                ;;   (*r3)()
  ;; ...                    ;; }
  \end{ca65code}
  \caption{GPIOINT Dispatcher in assembly with O1}
  \label{lst:gpio:asm:O1}
\end{listing}

At O1 the compiler has performed \gls{cse} to remove the duplicate load present in \autoref{lst:gpio:asm:O0}.
This can be eliminated with the assumption that the \code{gpioCallbacks} will not be changed by any external code.
But as the {\rust} version in \autoref{lst:irq-dispatch:rust} suggests this code can lead to a \concept{data race} because it is referencing a global mutable variable.

\subsection{Proposed solution}

The solution to this problem is quite straightforward by performening the \gls{cse} manually.
\autoref{lst:irq-dispatch:c-fixed} contains the implementation proposed to Silicon Labs to resolve this issue.

\begin{listing}[H]
  \begin{ccode}
static void GPIOINT_IRQDispatcher(uint32_t iflags) {
  while(iflags) {
    uint32_t irqIdx = GPIOINT_MASK2IDX(iflags);
    iflags &= ~(1 << irqIdx);
    GPIOINT_IrqCallbackPtr_t callback = gpioCallbacks[irqIdx];
    if (callback) {
      callback(irqIdx);
    }
  }
}
  \end{ccode}
  \caption{GPIOINT Dispatcher without data race}
  \label{lst:irq-dispatch:c-fixed}
\end{listing}

We again consult the generated assembly code, given in \autoref{lst:irq-dispatch:asm-fixed}, to verify that this resolved the issue at all optimization levels.

\begin{listing}[H]
  \begin{ca65code}
GPIOINT_IRQDispatcher:
  ;; ...                     ;;
  ldr   r3, .L34             ;; r3 = gpioCallbacks
  ldr   r2, [fp, #-8]        ;; r2 = irqIdx
  ldr   r3, [r3, r2, asl #2] ;; r3 = gpioCallbacks[irqIdx]
  ;; ...                     ;;
  cmp   r3, #0               ;; if (r3 == 0) {
  ;; ...                     ;;
  bx    r3                   ;;   (*r3)()
  ;; ...                     ;; }
  \end{ca65code}
  \caption{GPIOINT Dispatcher for proposed solution at O0}
  \label{lst:irq-dispatch:asm-fixed}
\end{listing}

\subsection{Discussion}

The issue presented in this section is a minor one and will probably never cause a \func{HardFault} in a real world application.
Nevertheless, it serves as an example of how the {\unsafe} keyword in {\rust} makes the programmer think twice about the code in these unsafe sections.
% It also points to the gains of using {\rust} to prototype subsets of an C library to see if issues with a more strict compiler will arise from the patterns and constructs used.

This discussion also points to the gains that can be achieved by using {\rust} to prototype subsets of a {\C} library.
It can be interesting to see if more issues like this one will arise, just by introducing the patterns and constructs from the {\rust} language and the strict {\rustc} compiler.
