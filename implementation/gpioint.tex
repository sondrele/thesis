\section{Porting GPIO Interrupt Driver}

This section considers a case study of an issue discovered while porting the \gls{gpio} interrupt driver from \lib{emdrv} to {\rust}.
The issue was discoverd when annotating the \texttt{unsafe} blocks for referencing mutable global state and gives an example of the awareness the inclusion of the {\unsafe} keyword provides.

\subsection{Presenting the Problem}

The \texttt{gpioint} driver lets the user registers a callback function to be called when an interrupt occures at a given \gls{gpio} pin.
It is implemented with a global mutable list of 16 function pointers, a register function to assign functions to indices of the list corresponding to \gls{gpio} pins, and a dispatch mechanisms which calls the correct functions when an interrupt occurs.
The issue arises in the dispatch function in \autoref{lst:irq-dispatch:c}.

\begin{listing}
  \begin{minted}{c}
static void GPIOINT_IRQDispatcher(uint32_t iflags) {
  while(iflags) {
    // Utility for iterating through all active interrupt signals
    uint32_t irqIdx = GPIOINT_MASK2IDX(iflags);
    // Mark interrupt as handled
    iflags &= ~(1 << irqIdx);
    // Check if the interrupt has a callback
    if (gpioCallbacks[irqIdx]) {
      // Call the callback
      gpioCallbacks[irqIdx](irqIdx);
    }
  }
}
  \end{minted}
  \caption{GPIO Dispatcher from emlib}
  \label{lst:irq-dispatch:c}
\end{listing}

\begin{listing}
  \begin{minted}{rust}
static mut GPIO_CALLBACKS: [Option<fn(u8)>; 16] = [None; 16];

fn dispatcher(iflags: u32) {
  while(iflags) {
    // Utility for iterating through all active interrupt signals
    let irq_idx = mask_to_index(iflags);
    // Mark interrupt as handled
    iflags &= !(1 << irq_idx);
    // Check if the interrupt has a callback
    if (unsafe { GPIO_CALLBACKS[irq_idx] }.is_some()) {

      // Window of opportunity

      // Unwrap the callback and call the function
      unsafe { GPIO_CALLBACKS[irq_idx] }.unwrap()(irq_idx);
    }
  }
}
  \end{minted}
  \caption{GPIO Dispatcher naively ported to Rust}
  \label{lst:irq-dispatch:rust}
\end{listing}

A first take at porting the dispatcher function to Rust yields the code in \autoref{lst:irq-dispatch:rust}.
It is quite easy to see that the global mutable state is read twice.
This means that there is a possibility of the second reference to return a different value than the first.
For instance the function \func{GPIOINT\_CallbackUnRegister(uin32\_t pin)} will insert the value \mem{0x0} into the specified pin.
If this function is called inside a interrupt handler and this interrupt is triggered while the GPIO driver is dispatching an interrupt the function pointer can be set to \mem{0x0} between the check and the call.
Calling a function pointer that points to \mem{0x0} will cause a \func{HardFault}.

\subsection{Analysis of Assembly}
To dive a bit further into the issue and to prove that it is only present at optimization level O0 we consider the assembly code for the dispatcher.

The subsection of the \func{GPIOINT\_IRQDispatcher} in assembly generated by \prog{arm-none-eabi-gcc -O0 -S} is reproduced in \autoref{lst:gpio:asm:O0}.

\begin{listing}[H]
  \begin{minted}{ca65}
GPIOINT_IRQDispatcher:
  ;; ...                    ;;
  ldr r3, .L34              ;; r3 = gpioCallbacks
  ldr r2, [fp, #-8]         ;; r2 = irqIdx
  ldr r3, [r3, r2, asl #2]  ;; r3 = gpioCallbacks[irqIdx]
; start interrupt window    ;;
  cmp r3, #0                ;; if (r3 == 0) {
  beq .L30                  ;;
  ldr r3, .L34              ;;   r3 = gpioCallbacks
  ldr r2, [fp, #-8]         ;;   r2 = irqIdx
; end interrupt window      ;;
  ldr r3, [r3, r2, asl #2]  ;;   r3 = gpioCallbacks[irqIdx]
  ;; ...                    ;;
  bx  r3                    ;;   (*r3)();  call the function
  ;; ...                    ;; }
  \end{minted}
  \caption{GPIOINT Dispatcher in assembly with O0}
  \label{lst:gpio:asm:O0}
\end{listing}

Here we see a window of 4 instructions where the proposed harmfull interrupt can occure.
It is the \func{ldr} instruction just before the window opening and the one just after that causes the issue.
These two loads must load the same address for the logic to be valid, although the second one is just required to not load \mem{0x0} in order not to cause a \func{HardFault}.

Looking at the same assembler generated by compiling the code with \prog{arm-none-eabi-gcc -O1 -S} in \autoref{lst:gpio:asm:O1} we see that the issue has been eliminated.

\begin{listing}[H]
  \begin{minted}{ca65}
GPIOINT_IRQDispatcher:
  ;; ...                    ;;
  ldr r5, .L5               ;; r5 = gpioCallbacks
  ;; ...                    ;;
  and r3, r0, #255          ;; r3 = irqIdx
  ;; ...                    ;;
  ldr r3, [r5, r3, asl #2]  ;; r3 = gpioCallbacks[irqIdx]
  cmp r3, #0                ;; if (r3 == 0) {
  ;; ...                    ;;
  bxne    r3                ;;   (*r3)()
  ;; ...                    ;; }
  \end{minted}
  \caption{GPIOINT Dispatcher in assembly with O1}
  \label{lst:gpio:asm:O1}
\end{listing}

At O1 the compiler has performed \gls{cse} to remove the duplicate load present in \autoref{lst:gpio:asm:O0}.
This can be elimintated with the assumption that the gpioCallback will not be changed by external code.
But as the Rust version in \autoref{lst:irq-dispatch:rust} suggests this code can lead to a \concept{data race} because it is referencing a global mutable variable.

\subsection{Proposed solution}

The solution to this problem is quite straightforward by performening the \gls{cse} manually.
\autoref{lst:irq-dispatch:c-fixed} contains the implementation proposed to SiliconLabs to resolve this issue.

\begin{listing}[H]
  \begin{minted}{rust}
static void GPIOINT_IRQDispatcher(uint32_t iflags) {
  while(iflags) {
    uint32_t irqIdx = GPIOINT_MASK2IDX(iflags);
    iflags &= ~(1 << irqIdx);
    GPIOINT_IrqCallbackPtr_t callback = gpioCallbacks[irqIdx];
    if (callback) {
      callback(irqIdx);
    }
  }
}
  \end{minted}
  \caption{GPIOINT Dispatcher without Data Race}
  \label{lst:irq-dispatch:c-fixed}
\end{listing}

We again consult the assembly code in \autoref{lst:irq-dispatch:asm-fixed} generated to verify that this resolved the issue.

\begin{listing}[H]
  \begin{minted}{ca65}
GPIOINT_IRQDispatcher:
  ;; ...                     ;;
  ldr   r3, .L34             ;; r3 = gpioCallbacks
  ldr   r2, [fp, #-8]        ;; r2 = irqIdx
  ldr   r3, [r3, r2, asl #2] ;; r3 = gpioCallbacks[irqIdx]
  ;; ...                     ;;
  cmp   r3, #0               ;; if (r3 == 0) {
  ;; ...                     ;;
  bx    r3                   ;;   (*r3)()
  ;; ...                     ;; }
  \end{minted}
  \caption{GPIOINT Dispatcher for proposed solution at O0}
  \label{lst:irq-dispatch:asm-fixed}
\end{listing}

\subsection{Discussion}

The issue presented in this section is a minor one and will probably never cause a \func{HardFault} in a real world application.
Nevertheless is serves as an example of how the {\unsafe} keyword in Rust makes the programmer think twice about code in these unsafe sections.
It aslo points to the gains of using Rust to prototype subsets of an C library to see if issues with a more strict compiler will arise from the patterns and constructs used.
