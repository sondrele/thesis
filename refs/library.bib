Automatically generated by Mendeley Desktop 1.13.8
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Dhurjati2005,
abstract = {Traditional approaches to enforcing memory safety of programs rely heavily on run-time checks of memory accesses and on garbage collection, both of which are unattractive for embedded applications. The goal of our work is to develop advanced compiler techniques for enforcing memory safety with minimal run-time overheads. In this paper, we describe a set of compiler techniques that, together with minor semantic restrictions on C programs and no new syntax, ensure memory safety and provide most of the error-detection capabilities of type-safe languages, without using garbage collection, and with no run-time software checks, (on systems with standard hardware support for memory management). The language permits arbitrary pointer-based data structures, explicit deallocation of dynamically allocated memory, and restricted array operations. One of the key results of this paper is a compiler technique that ensures that dereferencing dangling pointers to freed memory does not violate memory safety, without annotations, run-time checks, or garbage collection, and works for arbitrary type-safe C programs. Furthermore, we present a new interprocedural analysis for static array bounds checking under certain assumptions. For a diverse set of embedded C programs, we show that we are able to ensure memory safety of pointer and dynamic memory usage in all these programs with no run-time software checks (on systems with standard hardware memory protection), requiring only minor restructuring to conform to simple type restrictions. Static array bounds checking fails for roughly half the programs we study due to complex array references, and these are the only cases where explicit run-time software checks would be needed under our language and system assumptions.},
author = {Dhurjati, Dinakar and Kowshik, Sumant and Adve, Vikram and Lattner, Chris},
doi = {10.1145/1053271.1053275},
file = {:home/sondre/Downloads/thesis/p73-dhurjati-memory-safety-in-embedded-programming.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {1},
pages = {73--111},
title = {{Memory safety without garbage collection for embedded applications}},
volume = {4},
year = {2005}
}
@article{Light2015,
author = {Light, Alex},
file = {:home/sondre/Downloads/thesis/reenix.pdf:pdf},
title = {{Reenix: Implementing a Unix-Like Operating System in Rust}},
year = {2015}
}
@article{Labs2014,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/efm32-brochure.pdf:pdf},
title = {{Mixed-Signal 32-bit Microcontrollers}},
year = {2014}
}
@article{Grossman2002,
abstract = {Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone is to let programmers control data representation and memory management without sacrificing type-safety. In this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. The design incorporates several advancements, including support for region subtyping and a coherent integration with stack allocation and a garbage collector. To support separate compilation, Cyclone requires programmers to write some explicit region annotations, but a combination of default annotations, local type inference, and a novel treatment of region effects reduces this burden. As a result, we integrate C idioms in a region-based framework. In our experience, porting legacy C to Cyclone has required altering about 8\% of the code; of the changes, only 6\% (of the 8\%) were region annotations.},
author = {Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James},
doi = {10.1145/543552.512563},
file = {:home/sondre/Downloads/thesis/cyclone-regions.pdf:pdf},
isbn = {1581134630},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
pages = {282},
title = {{Region-based memory management in cyclone}},
volume = {37},
year = {2002}
}
@article{Labs,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/EFM32GG-RM.pdf:pdf},
title = {{EFM32GG Reference Manual}},
year = {2014}
}
@article{Higashi2010,
author = {Higashi, Makoto and Yamamoto, Tetsuo and Hayase, Yasuhiro and Ishio, Takashi and Inoue, Katsuro},
doi = {10.1145/1808266.1808278},
file = {:home/sondre/Downloads/thesis/p79-higashi-control-interrupt-handler-for-data-race-detection.pdf:pdf},
isbn = {9781605589701},
issn = {02705257},
journal = {Proceedings of the 5th Workshop on Automation of Software Test - AST '10},
keywords = {[Electronic Manuscript],embedded systems,fault injection,interrupt-,race condition},
pages = {79--86},
title = {{An effective method to control interrupt handler for data race detection}},
url = {http://portal.acm.org/citation.cfm?doid=1808266.1808278},
year = {2010}
}
@article{Valhouli2010,
author = {Valhouli, Ca},
file = {:home/sondre/Downloads/thesis/Hammersmith\_Group\_\_\_Internet\_of\_Things\_\_\_2010.pdf:pdf},
journal = {The Hammersmith Group research report},
number = {february},
pages = {1--7},
title = {{The Internet of things: Networked objects and smart devices}},
url = {http://scholar.google.com/scholar?q=\%E2\%80\%9CThe+Internet+of+Things\%3A++Networked+Objects+and+Smart+Devices+hammersmith+group\&btnG=\&hl=en\&as\_sdt=0\%2C5\#\#0},
year = {2010}
}
@article{an0014_timer,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/an0014\_efm32\_timer.pdf:pdf},
title = {{AN0014 - Application Note}},
year = {2014}
}
@article{Labs2014_BIO_EXP,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/Biometric-EXP-EVB-UG.pdf:pdf},
title = {{Biometric EXP Evaluation Board User's Guide}},
year = {2014}
}
@article{Wilson1992,
abstract = {We survey basic garbage collection algorithms, and variations such as incremental and generational collection. The basic algorithms include reference counting, mark-sweep, mark-compact, copying, and treadmill collection. Incremental techniques can keep garbage collection pause times short, by interleaving small amounts of collection work with program execution. Generational schemes improve efficiency and locality by garbage collecting a smaller area more often, while exploiting typical lifetime characteristics to avoid undue overhead from long-lived objects.},
author = {Wilson, Paul R.},
doi = {10.1007/BFb0017182},
file = {:home/sondre/Downloads/thesis/gcsurvey.pdf:pdf},
isbn = {978-3-540-55940-5},
journal = {Memory Management},
number = {September},
pages = {1--42},
title = {{Uniprocessor garbage collection techniques}},
year = {1992}
}
@article{Labs2013_STK,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/stk3700\_user\_manual.pdf:pdf},
title = {{User manual - Starter Kit EFM32GG-STK3700}},
year = {2013}
}
@article{Swamy2006,
abstract = {The goal of the Cyclone project is to investigate how to make a low-level C-like language safe. Our most difficult challenge has been providing programmers with control over memory management while retaining safety. This paper describes our experience trying to integrate and use effectively two previously-proposed, safe memory-management mechanisms: statically-scoped regions and tracked pointers. We found that these typing mechanisms can be combined to build alternative memory-management abstractions, such as reference counted objects and arenas with dynamic lifetimes, and thus provide a flexible basis. Our experience - porting C programs and device drivers, and building new applications for resource-constrained systems - confirms that experts can use these features to improve memory footprint and sometimes to improve throughput when used instead of, or in combination with, conservative garbage collection. Â© 2006 Elsevier B.V. All rights reserved.},
author = {Swamy, Nikhil and Hicks, Michael and Morrisett, Greg and Grossman, Dan and Jim, Trevor},
doi = {10.1016/j.scico.2006.02.003},
file = {:home/sondre/Downloads/thesis/scp.pdf:pdf},
isbn = {0167-6423},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Cyclone,Memory management,Memory safety,Reaps,Reference counting,Regions,Unique pointers},
number = {2},
pages = {122--144},
title = {{Safe manual memory management in Cyclone}},
volume = {62},
year = {2006}
}
@article{Regehr2005,
abstract = {Interrupt-driven embedded software is hard to thoroughly test since it usually contains a very large number of executable paths. Developers can test more of these paths using random interrupt testing---firing random interrupt handlers at random times. Unfortunately, na\"{\i}ve application of random testing to interrupt-driven software does not work: some randomly generated interrupt schedules violate system semantics, causing spurious failures. The contribution of this paper is the design, implementation, and experimental evaluation of RID, a restricted interrupt discipline that hardens embedded software with respect to unexpected interrupts, making it possible to perform random interrupt testing and also protecting it from spurious interrupts after deployment. We evaluate RID by implementing it in TinyOS and then using random interrupt testing to find bugs and also to drive applications toward their worst-case stack depths.},
author = {Regehr, John},
doi = {10.1145/1086228.1086282},
file = {:home/sondre/Downloads/thesis/regehr-emsoft05.pdf:pdf},
isbn = {1595930914},
journal = {Proceedings of the 5th ACM international conference on Embedded software},
keywords = {embedded sys-,interrupt-driven software,random testing,sensor networks,tems},
pages = {290--298},
title = {{Random testing of interrupt-driven software}},
year = {2005}
}
@article{Labs2013_DK,
author = {Labs, Silicon},
file = {:home/sondre/Downloads/thesis/dk3750\_user\_manual.pdf:pdf},
title = {{User manual - Development Kit EFM32GG-DK3750}},
year = {2013}
}
@article{Orso2014,
author = {Orso, Alessandro and Rothermel, Gregg},
file = {:home/sondre/Downloads/thesis/testing.pdf:pdf},
isbn = {9781450328654},
keywords = {software testing},
pages = {117--132},
title = {{Software Testing: A Research Travelogue (2000â2014)}},
year = {2014}
}
