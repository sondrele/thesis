% !TEX root = ../main.tex

\subsection{Peripherals}
\label{sub:peripherals}

In this project we have focused on writing software for the Giant Gecko series of microcontrollers.
We have utilized two different development boards that both features the EFM32GG990 microcontroller,
thus we have limited implementation of bindings to only support a handful of peripherals that are
available with this device. A block diagram of the device and its peripherals are shown in
\autoref{fig:efm32gg990_block_diagram}.

\begin{figure}[tb]
\centering
\missingfigure{EFM32GG990 block diagram}
\caption{Some caption}
\label{fig:efm32gg990_block_diagram}
\end{figure}

For this project, the porting of library bindings are only interesting if the peripherals exposed by
the library are actually going to be used. The two boards we have access to implements many external
sensors and peripherals that are all controlled through \emlib. It is only interesting to write
bindings and abstractions for the core functionality of \emlib and the parts of the library that
lets us control peripherals that we use in throughout the projects.


\subsection{Bindings for emlib} % (fold)
\label{sub:interfacing_with_emlib}

The \gls{ffi} available in Rust has been used to interface with emlib. This way, we have been able
to create thin wrappers around the emlib peripheral \gls{api} for the different peripherals that we
have used in the project, without porting the core logic itself. The following sections explains the
process of defining the \gls{ffi} in Rust that is used to access the \gls{cpu} and the peripherals
on the EFM32 STK. We will start by showing an example of what it is like to use emlib with C, and
then move over to what it looks like in Rust.

The \gls{ffi} bindings for the Timer module \cite{an0014_timer} provides for a good example of what
the Rust bindings looks like. The Timer module is fairly small, mostly exposing functions to set up
and initialize timers that can be used for up, down, up/down, and input- and output-capture. The
program shown in \autoref{lst:timer_program_c} first starts the clock and acquires an initialization
structure for the Timer module. Then it enables interrupts and initializes the module. The interrupt
vector is set up to call the function shown in \autoref{lst:timer_interrupt_handler}, all it does is
clearing the interrupt and toggle the value of an LED. Note that this program is not a complete
working example, it only shows the most important parts required to use the Timer module.

\begin{listing}[tb]
\begin{minted}{c}
/* Enable clock for TIMER0 module */
CMU_ClockEnable(cmuClock_TIMER0, true);

/* Select TIMER0 parameters */
TIMER_Init_TypeDef timerInit = TIMER_INIT_DEFAULT;

/* Enable overflow interrupt */
TIMER_IntEnable(TIMER0, TIMER_IF_OF);

/* Enable TIMER0 interrupt vector in NVIC */
NVIC_EnableIRQ(TIMER0_IRQn);

/* Set TIMER Top value */
TIMER_TopSet(TIMER0, TOP);

/* Configure TIMER */
TIMER_Init(TIMER0, &timerInit);
\end{minted}
\caption{Caption here}
\label{lst:timer_program_c}
\end{listing}

The equivalent program written in Rust is shown in \autoref{lst:timer_program_rust}. Semantically
they are the same, but the usage differs slightly, which is natural since we are using a
higher-order programming language. Instead of calling functions that are included through a C header
file, we are calling functions that are available through a Rust module. It is also worth to notice
the difference of how the Timer0 structure can be treated like an object in Rust, instead of
explicitly passing it to every function that requires it in C.

\begin{listing}[tb]
\begin{minted}{rust}
/* Enable clock for TIMER0 module */
cmu::clock_enable(cmu::Clock::TIMER0, true);

/* Select TIMER0 parameters */
let timer_init = Default::default();

/* Enable overflow interrupt */
let timer0 = timer::Timer::timer0();
timer0.int_enable(timer::TIMER_IF_OF);

/* Enable TIMER0 interrupt vector in NVIC */
nvic::enable_irq(nvic::IRQn::TIMER0);

/* Set TIMER Top value */
timer0.top_set(TOP);

/* Configure TIMER */
timer0.init(&timer_init);
\end{minted}
\caption{Caption here}
\label{lst:timer_program_rust}
\end{listing}

\begin{listing}[tb]
\begin{minted}{c}
void TIMER0_IRQHandler(void) {
  /* Clear flag for TIMER0 overflow interrupt */
  TIMER_IntClear(TIMER0, TIMER_IF_OF);

  /* Toggle LED ON/OFF */
  GPIO_PinOutToggle(LED_PORT, LED_PIN);
}
\end{minted}
\caption{Timer Interrupt Handler}
\label{lst:timer_interrupt_handler}
\end{listing}

In order to work with structures and enums originally defined in C, we had to re-define them in Rust
and mark them with \texttt{\#[repr(C)]} so that Rust guarantees that the data-elements are C
compatible. The header files in the peripheral \gls{api} also defines many functions as
\texttt{static inline}, which only makes the functions accessible by including the header file.
Since it is not possible to include header files directly in Rust, we had to expose these functions
through one extra layer with C code. As an example, the \texttt{TIMER\_IntEnable} function is defined
as \texttt{static inline} in \texttt{em\_timer.h}, in order to call this function through Rust we
have to expose it through the file \texttt{timer.c}, as shown in
\autoref{lst:exposing_static_inline}. In the Rust module definition of Timer, the function has to
be made available through the \texttt{extern} block shown in \autoref{lst:rust_ffi_example}. Every
function available through the \gls{ffi} are defined as \texttt{unsafe} because Rust knows nothing
of what the function does, other than what it takes as parameters and what value it returns. Thus,
in order to make it practical to use the library in a seemingly safe manner, we wrap the calls to
the foreign functions in an \texttt{unsafe} block in the respective function defined in Rust.

\begin{listing}[tb]
\begin{minted}{c}
#include "en_timer.h"

void STATIC_INLINE_TIMER_IntEnable(TIMER_TypeDef *timer, uint32_t flags) {
    TIMER_IntEnable(timer, flags);
}
\end{minted}
\caption{Exposing a function declared as \texttt{static inline}}
\label{lst:exposing_static_inline}
\end{listing}


\begin{listing}[tb]
\begin{minted}{rust}
impl Timer {
    pub fn int_enable(&self, flags: u32) {
        unsafe { STATIC_INLINE_TIMER_IntEnable(self, flags)}
    }
}

extern {
    fn STATIC_INLINE_TIMER_IntEnable(timer: &Timer, flags: u32);
}
\end{minted}
\caption{Defining and using a function through the Rust \gls{ffi}.}
\label{lst:rust_ffi_example}
\end{listing}

If we compare the call-stack when calling the \texttt{timer0.int\_enable} function in Rust with
calling the \texttt{TIMER\_IntEnable} function in C, we can see that every function call through the
\gls{ffi} requires two extra function calls. These are simple wrappers which require extra
unconditional jumps in the assembly, but it should be possible to get rid of the extra overhead
with link-time optimizations, thereby making the emlib-bindings a zero-cost abstraction over
Silicon Labs emlib peripheral \gls{api}.
\todo{We have not gotten this to work yet}

\todo[inline]{This whole section needs rewrite. A lot of the content (code examples etc.) might not
be interesting for the report at all.}

\subsubsection{Naming conventions}

We have tried to keep \emlib's naming convention across the bindings. This makes it easy for anyone
reading either the \C- or the \rust-code to translate and understand the code between the two
languages. Since every constant, enum-field or struct-name is directly accessible by name in \C if
the corresponding header file is included in the source code, it is important that names of such
fields can be separated from each other, and do not cause a naming collision. Such practices is  As an example, two
fields of an enum from \texttt{em\_timer.h} is shown in \autoref{lst:enum_naming_c}. From each field in
the enum we can extract 1) its module name \textit{timer}, 2) its typedef name \textit{CCMode} and
3) its field name \textit{Off} or \textit{Capture}. \rust allows us to keep the same naming
convention at the same time as utilizing \rust's modularity. Consider the ported enum in
\autoref{lst:enum_naming_rust} where both the module name and the typedef name has been left out,
and only the field name has remained. However, the naming convention remains the same when the
fields are used, e.g. the expression \texttt{let mode = timer::CCMode::Capture;} in \rust shows the
similarity with the equivalent expression in \C: \texttt{int mode = timerCCModeCapture;}.



\begin{listing}[tb]
\begin{minted}{c}
typedef enum {
  timerCCModeOff     = _TIMER_CC_CTRL_MODE_OFF,
  timerCCModeCapture = _TIMER_CC_CTRL_MODE_INPUTCAPTURE,
  // ...
} TIMER_CCMode_TypeDef;
\end{minted}
\caption{C enum naming convention}
\label{lst:enum_naming_c}
\end{listing}

\begin{listing}[tb]
\begin{minted}{rust}
pub enum CCMode {
  Off     = _TIMER_CC_CTRL_MODE_OFF,
  Capture = _TIMER_CC_CTRL_MODE_INPUTCAPTURE,
  // ...
}
\end{minted}
\caption{Rust enum naming convention}
\label{lst:enum_naming_rust}
\end{listing}

% subsection interfacing_with_emlib (end)

\subsubsection{Testing}



\subsection{Thoughts/Review}

Writing the bindings for different the peripherals was a tedious work, that required careful review
of the \emlib source code in order to correctly port enum- and struct-definitions from \C to \rust.
Additionally, we had to re-define many constants, like the names of register bit-fields or values
calculated from \C macros, from header files that are used throughout the library. If the value of
the constants not directly defined in the headers, we had to retrieve them by debugging the source
code and looking up the values explicitly.

Since we have constrained our library to only support the EFM32GG990 devices we chose to manually
write the bindings the library, instead of generating the bindings with some kind of automated
process. There were already a couple of tools available for generating \C-bindings automatically,
that could possibly have made the process quicker, but reasons for why we didn't utilize such tools
are described below.

\begin{enumerate}
    \item It is quick and easy to get started with code for a new peripheral. This argument was
    especially important when the project started out, because we still had no clue of how the
    project would evolve and what it was going to look like.
    \item It would be an advantage to not depend on as many different tools as possible, since both
    \rust and all available libraries would be in constant change until the 1.0 release of the
    language.
    \item We wanted to keep the naming convention of our bindings as similar to \emlib as possible,
    this would not have been easy to keep consistent with an automated process, partly because there
    are exceptions where these conventions do not fully hold. It is however an interesting problem
    that would have a higher priority if the library were ever to support more than one EFM32
    device.
    \item We could focus on writing bindings for each module separately when we needed them, which
    would split the work into smaller work-packages.
\end{enumerate}
