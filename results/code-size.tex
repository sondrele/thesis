\section{Code Size}

This section looks at the size of the end object files for various Rust libraries and examples.
A comparison with the size of identical programs implemented in C is also included.

Code size is an important factor in an embedded system.
Primarly the system is more restricted than conventional systems exspecially when it comes to storage.
For the EFM32 line of microcontrollers the code is stored in flash memory.
In \autoref{efm32-family} in \autoref{sec:back:hw} we showed that the flash memory in the EFM32 family of microcontrollers ranges from 4kB to 1024kB.
As \autoref{sec:before-main} explains the flash memory should not only contain the program code but also the constant data defined in the program.
This limits the code size even further.

Each program was compiled with optimization levels O0, O1, O2 and O3, the O0 level is compiled both with and without debugging symbols.
Compiling the library results in a lib*.rlib file which is an archive containing object files for the code contained in the library.
Compiling executable programs results in an elf binary file.
The size is then calculated by executing the \emph{arm-none-eabi-gcc} program.

\subsection{Measuring Size}

The \emph{arm-none-eabi-gcc} program accepts an elf binary, an object file or an archive as argument.
The program then reads the file and reports the size of the \textbf{text}, \textbf{data}, \textbf{bss} sections described in \autoref{sec:back:elf}.
If the argument is an archive the program will iterate through all the objects in the archive an report the size for each individual file.

\subsection{Parameters}
\label{sec:size:params}
The programs was generated by setting the \emph{profile} parameters of in the Cargo.toml file, described in \autoref{sec:cargo:profile}.
The parameters used are shown in \autoref{tab:size:params} with their effect.

\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    Parameter & Values & Effect \\
    \hline
    debug & true, false & sets the \textbf{-g} flag on the compilers  \\
    debug-assertions & true, false & a way to remove assertion statements \\
    opt-level & 0, 1, 2, 3 & sets the optimization flag on the compilers \\
    lto & true, false & sets the Link Time Optimization flag on the linker \\
    \hline
  \end{tabular}
  \caption{Cargo.toml profile parameters and their effect}
  \label{tab:size:params}
\end{table}

Each program in this section is compiled with 5 different settings as given by \autoref{tab:size:settings}.
\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    & 1     & 2     & 3     & 4     & 5     \\
    \hline
    debug            & true  & false & false & false & false \\
    debug-assertions & true  & false & false & false & false \\
    opt-level        & 0     & 0     & 1     & 2     & 2     \\
    lto              & false & true  & true  & true  & true  \\
    \hline
  \end{tabular}
  \caption{Compilation settings}
  \label{tab:size:settings}
\end{table}

\subsection{Libraries}

This section looks at the code size the REL libraries along with the cmsis and startup libraries.
The REL libraries are all Rust code, while the cmsis and startup libraries contain bindings C code and the actual C code compiled with gcc.
The same compiler options from \autoref{sec:size:params} applies to the C compiler aswell.
As the code size of libraries varies from a few bytes to 400KB the results are presented in two separate figures.
\autoref{fig:size:lib:small} shows the small libraries ranging from 4B to 3KB and \autoref{fig:size:lib:large} shows the large libraries in ranges 100KB to 400KB.

Both figures distinguises between the three sections reported by the \emph{size} program but only the \textbf{text} segment is prominent.
This is because there is not much allocation in the the REL libraries, in fact the only allocation is 8B in the \textbf{data} section of the startup library.

The bars for each library from left to right represents the sizes of programs compiled with different parameters as described in \autoref{tab:size:settings}.
The general trend is that the code size decrease when the optimization level is incresased.

\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.3]{results/plots/size/lib/small/size.png}
  \end{center}
  \caption{Code size for small Rust libraries}
  \label{fig:size:lib:small}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=0.3]{results/plots/size/lib/large/size.png}
  \end{center}
  \caption{Code size for large Rust libraries}
  \label{fig:size:lib:large}
\end{figure}
\todo{do subfigure when oo section lands the packages}

A notable result in \autoref{fig:size:lib:small} is the increase in code size for the startup library when moving from O2 to O3.
This increase of 500B is not in the Rust section of the startup library but the CMSIS Cortex-M3 System Layer provided by Silicon Labs.
We see that the code footprint of the libc implementation is only 4B when compiled with debugging symbols and actually disappears completely when the library is optimized.
This points the fact that Rust delivers a Zero Cost Abstraction when calling C through \emph{ffi} without safe wrappers.
The libc only responsibilty is to expose a few functions and provide type aliases for using C specific datatypes.
All of these are static abstractions and can be removed at compile time.

\autoref{fig:size:lib:large} shows that some of the central libraries in REL are quite large.
An importaint point here is that although the \emph{core} library by it self is over 100KB when optimized for size a program utilizing the library can be substantially smaller.
This is because of the fact that a library build must provide all the functionality of the source code, while an executable build can eliminate all the functionality of the library that is not used.

By considering the size of the largest and the smallest build for each program we see that the compress factor when applying optimizations is 2.3x on average.

\subsection{Executables}
