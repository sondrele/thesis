% !TEX root = ../main.tex

\section{Rust for ARM} % (fold)
\label{sec:rust_for_arm}

Before we started on this thesis we were already aware that there were a couple of other projects that was running {\rust} bare-metal on ARM \glspl{mcu}.
We did, however, not know how easy it would be to get up and running with {\rust} on the EFM32.
It took us less than one day to implement and execute a {\rust} blink-demo on the {\STK}.
The {\rust} documentation was sufficient for figuring out how to define non-std {\rust} programs (i.e. the ones that are annotated with \texttt{\#[no\_std]}), and projects like \texttt{armboot} helped us to build the project for the ARM architecture.
{\rust}'s runtime is comparable with the one that is available in C, the startup-routine in the two languages are the same, but the {\core} library is larger and provides more functionality than the C standard library, which we consider to be an added bonus of rust.
{\rust} has a rich standard library which offers a strong foundation for all the programs that want to depend on it.
As we described in X, the {\std} crate acts like an abstraction over all the different libraries in \gls{rsl} and the rustc compiler is itself dependent on a couple of \emph{marker-traits} to be present in this module.
It is easy enough to define programs that are not dependent on this {\std} library, and instead only dependent on {\core}, but we think the distinction between {\std} and {\core} is too big.

\gls{rcl} do provide us with with enough functionality to write idiomatic {\rust} code, but we had to implement a few workarounds in order to get support for {\rust}'s standard constructs for dynamic memory allocation.
Currently, {\rust} does not have functionality to provide, or automatically compile, any of its standard libraries for other target architectures than the ones it support by default.
Because our project targets an ARM processor architecture, we have to conditionally compile the libraries (like alloc and collections) that has functionality that we want to utilize, for this architecture.
This is not necessarily a big problem in itself, it does not complicate the process much more than the need to explicitly define the libraries as custom dependencies in the \texttt{Cargo.toml}.
We do however think that the distinction between standard and non-standard programs, make it considerably harder to enable us to use the great ecosystem that {\rust} is surrounded by.

We have described Cargo and its ability to manage package dependencies, and closely associated with Cargo is its package repository called \texttt{crates.io} \footnote{http://crates.io}.
This repository stores, at the time of this writing, a couple of thousand different {\rust} crates, all made available for anyone that builds {\rust} programs with Cargo.
The vast majority of these crates are, to the best of our knowledge, linked to {\std} and utilize some part of it, either directly or transitively through a package dependency.
That being said, they do not necessarily use any functionality that we have not already made available through \gls{rel} in our project.
This simple fact renders nearly all (if not all) packages available through \texttt{crates.io} unusable for our project, even though the same basis that many of these package depend on might already be available in \gls{rel}.

