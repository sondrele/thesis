% !TEX root = ../main.tex

\section{Rust for ARM} % (fold)
\label{sec:disc:rust_for_arm}
% \todo{Mention this in discussion. Is there a better way of solving this? Currently it fetches a release tarball of the language. It fetches more than it needs to for each library, but it's quicker/easier than using e.g. git to do it. It does however take a little while to compile all the dependencies on smaller machines.}

Before we started on this thesis, we were already aware that there were a couple of other projects that were running {\rust} bare-metal on ARM \glspl{mcu}.
We did, however, not know how easy it would be to get up and running with {\rust} on the EFM32.
It took us less than one day to implement and execute a {\rust} blink-demo on the {\STK}.
The {\rust} documentation was sufficient for figuring out how to define non-std {\rust} programs (i.e. the ones that are annotated with \texttt{\#[no\_std]}), and projects like \texttt{armboot} helped us build the project for the ARM architecture.
{\rust}'s runtime is comparable to {\C}'s, because the startup routine in the two languages is the same, but {\rust}'s {\core} library is larger and provides more functionality than the {\C} standard library, which we consider to be an added bonus of {\rust}.

{\rust} has a rich standard library that offers a strong foundation for all the programs that want to depend on it.
As we described in \autoref{ssub:rust:features}, the {\std} crate acts like an abstraction over all the different libraries in \gls{rsl} and the {\rustc} compiler is itself dependent on a couple of traits to be present in this module.
It is easy enough to define programs that are not dependent on this {\std} library, and instead only dependent on {\core}, but we think the difference between {\std} and {\core} is too large.

\gls{rcl} does provide us with enough functionality to write idiomatic {\rust} code, but we had to implement a few workarounds in order to get support for {\rust}'s standard constructs for dynamic memory allocation.
Currently, {\rust} does not have functionality to provide, or automatically compile, any of its standard libraries for target architectures other than the ones it supports by default.
Because our project targets an ARM processor architecture, we have to conditionally download and compile the libraries (like \lib{alloc} and \lib{collections}) that have functionality that we want to utilize, as described in \autoref{ssub:transitioning_to_cargo}.
This is not necessarily a big problem in itself, as it does not complicate the process much more than the need to explicitly define the libraries as custom dependencies in the \texttt{Cargo.toml}.
We do, however, think that the distinction between standard and non-standard programs make it considerably harder to enable us to use the great ecosystem that {\rust} is surrounded by.

We have described {\cargo} and its ability to manage package dependencies, and a package repository closely associated with {\cargo} is called \texttt{crates.io}\footnote{\url{https://crates.io}}.
This repository stores, at the time of this writing, a couple of thousand different {\rust} crates, all made available for anyone who builds {\rust} programs with {\cargo}.
The vast majority of these crates are, to the best of our knowledge, linked to {\std} and utilize some part of it, either directly or transitively through a package dependency.
That being said, they do not necessarily use any functionality that we have not already made available through \gls{rel} in our project.
This simple fact renders nearly all (if not all) packages available through \texttt{crates.io} unusable for our project, even though the same basis that many of these packages depend on might already be available through \gls{rel}.

As an example to demonstrate this problem, we look to the \texttt{lazy-static}\footnote{\url{https://crates.io/crates/lazy_static}} project available on \texttt{crates.io}.
This project allows the programmer to declare \emph{static} variables that get initialized at \emph{runtime}.
It provides some of the same functionality that we implemented for the event-hub described in \autoref{sec:irq-closures}.
We can not use this project directly because it depends on {\std}, but if we look closer at the project's source code, we can see that the project author has implemented an alternate (and outdated) version which is only dependent on {\core}.
Another example is the \texttt{smallvec}\footnote{\url{https://crates.io/crates/smallvec}} project, which provides a handful of optimized versions of {\rust}'s vector structure that have a length-limit of 32 entries.
Similar to the \texttt{lazy-static} project, all the dependencies for \texttt{smallvec} are included from {\std}, but are also available in {\core}.
We have implemented a structure that is similar to \texttt{smallvec} as part of the {\tracker} application, but it feels like an unnecessary addition because it is already available on \texttt{crates.io} \emph{and} it only depends on features from {\core}.

This distinction between {\std} and \gls{rsl} feels somewhat contradictory to {\rust}'s focus on modularization and package distribution with {\cargo}.
It also feels destructive for non-standard projects like ours, because we would either have to re-implement or modify the already existing projects in order to get them to work for our platform.
We hope that it will get easier in time to define non-standard projects, while simultaneously being able to utilize many of the great open-source libraries that are already available.
