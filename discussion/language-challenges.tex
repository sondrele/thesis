\section{Language Challenges}

In \autoref{sec:assignment} we identified six language challenges that must be considered when using a language in an embedded system.
Here we will look at each challenge and discuss how the challenges was solved for the {\rg} platform.

\begin{description}
\item [LC1 Volatile read and write] \hfill \\
  {\rust} exposes two \concept{intrinsics} for handling volatile read and write.
  These makes the code more verbose compared to the mechanism in {\C}, where a variable is marked with the \code{volatile} keyword.
  In {\rust}, the intrinsic functions must be used each time a variable is read or written, this however gives the programmer more fine-grained control as a variable can be used both as volatile and non-volatile.

\item [LC2 Handling interrupts] \hfill \\
  Interrupt handlers must use the {\C} \gls{abi}, because the interrupts are dispatched from the {\C} runtime.
  This makes the code more verbose, but it is easily achievable.
  As discussed in \autoref{sec:ownership_allied_to_hardware}, a downside to the interrupted programming model found in embedded programming for {\rust} is the reliance on global mutable state.
  In these circumstances the compiler is limited in its ability to staticaly verify safety, this is because accesses to these variables must be contained inside {\unsafe} blocks.

\item [LC3 Reading and writing hardware registers] \hfill \\
  In this thesis we have only considered hardware devices as \glspl{mmio}.
  As {\rust} supports raw pointers and lets the programmer access arbritary memory addresses and cast these as structs, the handling of hardware registers are equally practical in {\rust} as in {\C}.
  Given a more mature embedded platform in {\rust}, we foresee that even more of the compile-time ownership analysis provided by the {\rust} compiler can be used to ensure safe interactions with hardware registers.

\item [LC4 Static object construction] \hfill \\
  {\rust} (and {\C}) have, unlike many other programming languages, no life before the {\main} function.
  In this statement lies the fact that in the global scope, one can only initialize objects which have constant initializers.
  Therefore all the initializers contain constant data only and they can be handled by the startup mechanisms described in \autoref{sec:back:startup}.
  This implies that the static object construction problem is non-existent in {\rust} programs.

\item [LC5 Heap allocation] \hfill \\
  Dynamic allocation in {\rust} is implemented in the \lib{alloc} library.
  We were easily able to include this functionality in \gls{rel}.
  In \autoref{sec:res:heap} we showed that the heap allocation in {\rust} and {\C} work the same.
  This is due to the allocation algorithm in {\rust} is directly dependent on the \lib{newlib} \func{malloc} implementation, and therefore the memory fragmentation is equal to that of the existing {\C} platform.

\item [LC6 Error handling without allocation] \hfill \\
  When the {\rust} allocator runs out of memory it will call a function which is defined in the \lib{alloc} library.
  At the time of writing, this function does not provide any error handling, it only calls a compiler \concept{intrinsic} to abort the program.
  This means that a {\rust} program which runs out of memory will not end up in an infinite error handling loop, but the program ends up with a HardFault.

\end{description}
